// src/core/services/CheckoutService.ts - ACTUALIZADO CON DESCUENTOS POR VOLUMEN
import ApiClient from "../../infrastructure/api/apiClient";
import {API_ENDPOINTS} from "../../constants/apiEndpoints";
import {extractErrorMessage} from "../../utils/errorHandler";
import type {Address} from "../domain/valueObjects/Address";
import type {ShoppingCart} from "../domain/entities/ShoppingCart";
import {CheckoutItemsService} from "../../infrastructure/services/CheckoutItemsService";
import type {CheckoutItem} from "../../infrastructure/services/CheckoutItemsService";
import { validateTotalsEquality } from "../../constants/calculationConfig";

export type PaymentMethod = "credit_card" | "paypal" | "transfer" | "qr" | "datafast" | "debit_card" | "de_una";

export interface PaymentInfo {
	method: PaymentMethod;
	card_number?: string;
	card_expiry?: string;
	card_cvc?: string;
	paypal_email?: string;
}

// ‚úÖ ACTUALIZADO: Interface CheckoutRequest con precios finales
export interface CheckoutRequest {
	payment: PaymentInfo;
	shippingAddress: Address;
	billingAddress?: Address;
	seller_id?: number;
	items?: CheckoutItem[]; // ‚úÖ Usar CheckoutItem con precios finales
	discount_code?: string | null; // ‚úÖ NUEVO: C√≥digo de descuento
	discount_info?: any; // ‚úÖ NUEVO: Informaci√≥n completa del descuento aplicado
	calculated_totals?: { // ‚úÖ CR√çTICO: Agregar totales calculados
		subtotal: number;
		tax: number;
		shipping: number;
		total: number;
		total_discounts: number;
	};
}

export interface BackendCheckoutRequest {
	payment: PaymentInfo;
	shipping: {
		first_name: string;
		last_name: string;
		email: string;
		phone: string;
		address: string;
		city: string;
		state: string;
		postal_code: string;
		country: string;
	};
	seller_id?: number;
	items?: CheckoutItem[]; // ‚úÖ Usar CheckoutItem con precios finales
	discount_code?: string; // ‚úÖ FIX: Opcional - solo se incluye si hay cup√≥n
	// ‚úÖ CR√çTICO: Totales exactos calculados que el backend DEBE usar
	calculated_totals?: {
		subtotal: number;
		tax: number;
		shipping: number;
		total: number;
		total_discounts: number;
	};
}

export interface CheckoutResponse {
	status: string;
	message: string;
	data: {
		order_id: string;
		order_number: string;
		total: string;
		payment_status: string;
		// ‚úÖ NUEVOS: Campos de pricing con descuentos
		billed_amount?: number;
		paid_amount?: number;
		total_savings?: number;
		volume_discounts_applied?: boolean;
		volume_discount_savings?: number;
		seller_discount_savings?: number;
	};
}

export class CheckoutService {
	/**
	 * Obtiene el seller ID del carrito de compras
	 */
	static getSellerIdFromCart(cart: ShoppingCart | null): number | null {
		if (!cart || !cart.items || cart.items.length === 0) {
			console.log("üõí getSellerIdFromCart: Carrito vac√≠o o sin items");
			return null;
		}

		console.log("üõí getSellerIdFromCart: Analizando carrito:", {
			totalItems: cart.items.length,
			items: cart.items.map((item) => ({
				id: item.id,
				productId: item.productId,
				quantity: item.quantity,
				productData: item.product,
			})),
		});

		const firstItem = cart.items[0];
		console.log("üõí getSellerIdFromCart: Primer item del carrito:", firstItem);

		if (firstItem.product) {
			console.log("üõí getSellerIdFromCart: Producto encontrado:", {
				sellerId: firstItem.product.sellerId,
				seller_id: firstItem.product.seller_id,
				seller: firstItem.product.seller,
				user_id: firstItem.product.user_id,
			});

			if (firstItem.product.sellerId) {
				console.log("‚úÖ getSellerIdFromCart: Usando sellerId:", firstItem.product.sellerId);
				return firstItem.product.sellerId;
			}

			if (firstItem.product.seller_id) {
				console.log("‚úÖ getSellerIdFromCart: Usando seller_id:", firstItem.product.seller_id);
				return firstItem.product.seller_id;
			}

			if (firstItem.product.seller && firstItem.product.seller.id) {
				console.log("‚úÖ getSellerIdFromCart: Usando seller.id:", firstItem.product.seller.id);
				return firstItem.product.seller.id;
			}

			if (firstItem.product.user_id) {
				console.log("‚úÖ getSellerIdFromCart: Usando user_id como fallback:", firstItem.product.user_id);
				return firstItem.product.user_id;
			}
		}

		console.warn("‚ùå getSellerIdFromCart: No se pudo obtener seller ID del carrito:", cart);
		return null;
	}

	/**
	 * ‚úÖ ACTUALIZADO: Procesar el pago usando precios con descuentos por volumen
	 */
	async processCheckout(
		checkoutData: CheckoutRequest,
		userEmail?: string
	): Promise<CheckoutResponse> {
		try {
			console.log("üöÄ CheckoutService.processCheckout INICIADO CON DESCUENTOS POR VOLUMEN");
			console.log("üì¶ Datos de checkout enviados:", JSON.stringify(checkoutData, null, 2));

			// ‚úÖ VALIDACI√ìN SEGURA: Verificar que address.name existe
			if (!checkoutData.shippingAddress.name) {
				throw new Error('El nombre en la direcci√≥n de env√≠o es requerido');
			}

			// ‚úÖ MAPEAR m√©todo de pago de manera m√°s robusta
			let paymentMethod: PaymentMethod = checkoutData.payment.method;
			
			// Mapeo de m√©todos de pago
			const methodMapping: Record<string, PaymentMethod> = {
				"transfer": "datafast",
				"credit_card": "credit_card",
				"debit_card": "debit_card", 
				"paypal": "paypal",
				"qr": "de_una",
				"datafast": "datafast",
				"de_una": "de_una"
			};

			if (methodMapping[paymentMethod]) {
				paymentMethod = methodMapping[paymentMethod];
			}

			console.log("üîç DEBUGGING - M√©todo despu√©s de mapear:", paymentMethod);

			// ‚úÖ PROCESAR ITEMS CON DESCUENTOS POR VOLUMEN
			const items = checkoutData.items || [];
			console.log("üîç DEBUGGING - Items recibidos:", items);

			if (items.length === 0) {
				console.warn("‚ö†Ô∏è No se recibieron items en checkoutData");
			}

			// ‚úÖ VALIDAR que los items tengan precios finales correctos
			const validation = CheckoutItemsService.validateItemsForCheckout(items);
			if (!validation.valid) {
				throw new Error(`Validaci√≥n de items fall√≥: ${validation.errors.join(', ')}`);
			}

			console.log("‚úÖ Items validados correctamente:", items);

			// ‚úÖ CONVERSI√ìN SEGURA: Mapear direcci√≥n a formato requerido por backend
			// ‚úÖ USAR CALCULADORA CENTRALIZADA PARA TOTALES EXACTOS
			const appliedDiscount = checkoutData.discount_info || 
				(checkoutData.discount_code ? { 
					discountCode: { 
						code: checkoutData.discount_code,
						discount_percentage: 5, // Valor por defecto si no se proporciona discount_info
						discount_amount: 0
					}
				} : null);
			
			// ‚úÖ CR√çTICO: NO RECALCULAR - Usar totales ya calculados que se pasaron como par√°metro
			console.log("üîç USANDO TOTALES PRECALCULADOS (NO SE RECALCULA):");
			console.log("   üìä calculated_totals recibidos:", checkoutData.calculated_totals);

			console.log("üîç FLUJO COMPLETO DE CHECKOUT CORREGIDO:");
			console.log("1Ô∏è‚É£ Items del carrito:", checkoutData.items?.length || 0);
			console.log("2Ô∏è‚É£ C√≥digo de descuento:", checkoutData.discount_code || "NINGUNO");
			console.log("3Ô∏è‚É£ appliedDiscount:", appliedDiscount);
			console.log("4Ô∏è‚É£ TOTALES EXACTOS CALCULADOS (CALCULADORA CENTRALIZADA):", checkoutData.calculated_totals);
			console.log("5Ô∏è‚É£ Total final CORRECTO que debe guardarse en DB:", checkoutData.calculated_totals?.total, "‚úÖ DEBE SER $8.87");

			const nameParts = (checkoutData.shippingAddress.name || '').split(' ');
			
			// ‚úÖ FIX CORREGIDO: Enviar shippingAddress y billingAddress directamente sin transformar
			const backendData: any = {
				payment: {
					...checkoutData.payment,
					method: paymentMethod
				},
				// ‚úÖ CUSTOMER: REQUERIDO PARA SRI (mantener para Datafast)
				customer: {
					given_name: nameParts[0] || '',
					surname: nameParts.slice(1).join(' ') || '',
					phone: checkoutData.shippingAddress.phone || '',
					doc_id: checkoutData.shippingAddress.identification || ''
				},
				// ‚úÖ CORRECCI√ìN CR√çTICA: Enviar shippingAddress y billingAddress con formato original
				shippingAddress: checkoutData.shippingAddress, // ‚úÖ Directo, sin transformar
				billingAddress: checkoutData.billingAddress,   // ‚úÖ A√ëADIDO: Faltaba por completo
				seller_id: checkoutData.seller_id,
				items: items, // ‚úÖ Usar items con precios finales calculados
				// ‚úÖ CR√çTICO: Enviar totales exactos de calculadora centralizada para que backend los use SIN RECALCULAR
				calculated_totals: checkoutData.calculated_totals || {
					subtotal: 0,
					tax: 0,
					shipping: 0,
					total: 0,
					total_discounts: 0
				}
			};
			
			// ‚úÖ FIX: Solo agregar discount_code si hay un cup√≥n v√°lido
			if (checkoutData.discount_code && checkoutData.discount_code.trim() !== "") {
				backendData.discount_code = checkoutData.discount_code.trim();
				console.log("‚úÖ Cup√≥n aplicado enviado al backend:", backendData.discount_code);
			} else {
				console.log("‚úÖ No hay cup√≥n - campo discount_code omitido del request");
			}

			console.log("üîç DEBUGGING - Datos CORREGIDOS enviados al backend:", JSON.stringify(backendData, null, 2));
			console.log("‚úÖ CORRECCI√ìN APLICADA: shippingAddress y billingAddress enviados con formato original");
			
			// ‚úÖ LOGS CR√çTICOS PARA TOTALES CORREGIDOS
			console.log("üí∞ TOTALES CR√çTICOS CORREGIDOS QUE DEBE USAR EL BACKEND:");
			console.log("   üìä Subtotal:", checkoutData.calculated_totals?.subtotal);
			console.log("   üìä IVA:", checkoutData.calculated_totals?.tax);
			console.log("   üìä Env√≠o:", checkoutData.calculated_totals?.shipping);
			console.log("   üìä TOTAL FINAL:", checkoutData.calculated_totals?.total, "‚úÖ DEBE SER $8.87");
			console.log("   üìä Total descuentos:", checkoutData.calculated_totals?.total_discounts);
			console.log("üö® EL BACKEND NO DEBE RECALCULAR - USAR ESTOS TOTALES EXACTOS");
			console.log("üö® TOTAL ESPERADO EN RESPUESTA:", checkoutData.calculated_totals?.total);

			// ‚úÖ VALIDACI√ìN FINAL antes de enviar
			if (backendData.items && backendData.items.length > 0) {
				for (let i = 0; i < backendData.items.length; i++) {
					const item = backendData.items[i];
					if (!item.hasOwnProperty('price') || item.price === undefined || item.price === null) {
						throw new Error(`FATAL: Item ${i} no tiene campo 'price' definido. Item: ${JSON.stringify(item)}`);
					}
					if (typeof item.price !== 'number' || item.price <= 0) {
						throw new Error(`FATAL: Item ${i} tiene precio inv√°lido: ${item.price} (tipo: ${typeof item.price})`);
					}
				}
				console.log("‚úÖ VALIDACI√ìN FINAL: Todos los items tienen precios finales v√°lidos");
			}

			const response = await ApiClient.post<CheckoutResponse>(
				API_ENDPOINTS.CHECKOUT.PROCESS,
				backendData
			);

			console.log("‚úÖ CheckoutService: Respuesta del backend:");
			console.log("üìä Status:", response.status);
			console.log("üí¨ Message:", response.message);
			console.log("üì¶ Data:", JSON.stringify(response.data, null, 2));

			// ‚úÖ LOG de informaci√≥n de descuentos si est√° disponible
			if (response.data && typeof response.data === "object") {
				const dataObj = response.data as any;
				
				if (dataObj.total_savings && dataObj.total_savings > 0) {
					console.log("üí∞ DESCUENTOS APLICADOS EN LA ORDEN:");
					console.log(`üíµ Total ahorrado: $${dataObj.total_savings}`);
					
					if (dataObj.volume_discount_savings) {
						console.log(`üìà Descuentos por volumen: $${dataObj.volume_discount_savings}`);
					}
					
					if (dataObj.seller_discount_savings) {
						console.log(`üè™ Descuentos del seller: $${dataObj.seller_discount_savings}`);
					}
				}
			}

			console.log("üéâ CheckoutService.processCheckout COMPLETADO CON DESCUENTOS POR VOLUMEN");
			return response;
		} catch (error) {
			console.error("‚ùå CheckoutService: Error al procesar checkout:");
			console.error("üìä Error object:", error);
			console.error("üìä Error message:", (error as any)?.message);
			console.error("üìä Error response:", (error as any)?.response?.data);

			// ‚úÖ DEBUGGING ADICIONAL para identificar el problema
			if ((error as any)?.response?.status === 400) {
				console.error("üîç ERROR 400 DETECTADO - Analizando request enviada:");
				console.error("üìä Payment method enviado:", checkoutData.payment.method);
				console.error("üìä Items enviados:", checkoutData.items);
				console.error("üìä Seller ID enviado:", checkoutData.seller_id);
			}

			const errorMessage = extractErrorMessage(
				error,
				"Error al procesar el pago. Por favor, intenta de nuevo m√°s tarde."
			);

			console.error("üìä Error message final:", errorMessage);
			throw new Error(errorMessage);
		}
	}

	/**
	 * Obtener el carrito actual
	 */
	async getCurrentCart(): Promise<any> {
		try {
			console.log("üõí Obteniendo carrito actual...");
			return null;
		} catch (error) {
			console.error("‚ùå Error al obtener carrito actual:", error);
			return null;
		}
	}

	/**
	 * ‚úÖ CORREGIDO: Preparar items del carrito con descuentos para checkout
	 */
	static async prepareCartItemsForCheckout(cartItems: any[], appliedDiscount: any = null): Promise<CheckoutItem[]> {
		console.log("üõí Preparando items del carrito con descuentos");
		console.log("üé´ Cup√≥n aplicado:", appliedDiscount?.discountCode?.code || "NINGUNO");
		
		const checkoutItems = await CheckoutItemsService.prepareItemsForCheckout(cartItems, appliedDiscount);
		
		// ‚úÖ Debug para verificar consistencia
		await CheckoutItemsService.debugItemPricing(cartItems, checkoutItems);
		
		console.log("‚úÖ Items preparados para checkout:", checkoutItems);
		
		return checkoutItems;
	}

	/**
	 * ‚úÖ NUEVO: Calcular totales para mostrar en checkout
	 */
	static calculateCheckoutTotals(cartItems: any[]) {
		return CheckoutItemsService.calculateCheckoutTotals(cartItems);
	}

	/**
	 * ‚úÖ ACTUALIZADO: Validar totales considerando descuentos por volumen
	 */
	static validateCheckoutTotals(cartTotal: number, checkoutTotal: number, customTolerance?: number): boolean {
		return validateTotalsEquality(
			cartTotal, 
			checkoutTotal, 
			'Validaci√≥n CheckoutService',
			customTolerance
		);
	}
}