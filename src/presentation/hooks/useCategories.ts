// src/presentation/hooks/useCategories.ts - CORREGIDO
import {useState, useCallback, useEffect} from "react";
import CacheService from "../../infrastructure/services/CacheService";
import appConfig from "../../config/appConfig";
import {CategoryService} from "../../core/services/CategoryService";
import type {Category} from "../../core/domain/entities/Category";

// Instanciar el servicio de categor√≠as
const categoryService = new CategoryService();

/**
 * Hook para gestionar operaciones con categor√≠as (solo lectura)
 */
export const useCategories = () => {
	const [loading, setLoading] = useState<boolean>(false);
	const [error, setError] = useState<string | null>(null);
	const [categories, setCategories] = useState<Category[]>([]);
	const [mainCategories, setMainCategories] = useState<Category[]>([]);
	const [featuredCategories, setFeaturedCategories] = useState<Category[]>([]);
	const [categoryDetail, setCategoryDetail] = useState<Category | null>(null);
	const [isInitialized, setIsInitialized] = useState<boolean>(false);

	// Adaptador para normalizar los datos de categor√≠as
	const adaptCategory = useCallback((apiCategory: any): Category => {
		// Verificar que sea un objeto para prevenir errores
		if (!apiCategory || typeof apiCategory !== "object") {
			console.error("Categor√≠a inv√°lida para adaptar:", apiCategory);
			return {} as Category;
		}

		// Mapeo de propiedades, respetando snake_case del backend
		return {
			id: apiCategory.id,
			name: apiCategory.name || "",
			slug: apiCategory.slug || "",
			description: apiCategory.description || "",
			parent_id: apiCategory.parent_id,
			icon: apiCategory.icon,
			image: apiCategory.image,
			order: apiCategory.order,
			is_active: Boolean(apiCategory.is_active ?? true),
			featured: Boolean(apiCategory.featured ?? false),
			created_at: apiCategory.created_at,
			updated_at: apiCategory.updated_at,
			// API response specific fields
			subcategories: Array.isArray(apiCategory.subcategories)
				? apiCategory.subcategories.map((sub: any) => adaptCategory(sub))
				: undefined,
			product_count: apiCategory.product_count || 0,
			full_path: apiCategory.full_path,
			has_children: Boolean(apiCategory.has_children),
			url: apiCategory.url,
			parent: apiCategory.parent
				? adaptCategory(apiCategory.parent)
				: undefined,
			image_url: apiCategory.image_url,
			icon_url: apiCategory.icon_url,
		};
	}, []);

	// Inicializaci√≥n - cargar categor√≠as si hay datos en cach√©
	useEffect(() => {
		if (!isInitialized) {
			// Verificar si hay categor√≠as en cach√©
			const cachedCategories = CacheService.getItem("categories_all");
			if (cachedCategories && cachedCategories.data) {
				setCategories(cachedCategories.data || []);
			}

			// Verificar si hay categor√≠as principales en cach√©
			const cachedMainCategories = CacheService.getItem(
				"categories_main_with_counts"
			);
			if (cachedMainCategories) {
				setMainCategories(cachedMainCategories);
			}

			// Verificar si hay categor√≠as destacadas en cach√©
			const cachedFeaturedCategories = CacheService.getItem(
				"categories_featured_8"
			);
			if (cachedFeaturedCategories) {
				setFeaturedCategories(cachedFeaturedCategories);
			}

			setIsInitialized(true);
		}
	}, [isInitialized]);

	/**
	 * Obtener todas las categor√≠as
	 */
	const fetchCategories = useCallback(
		async (withCounts: boolean = true, forceRefresh: boolean = false) => {
			setLoading(true);
			setError(null);

			const cacheKey = `categories_all_${withCounts ? "with_counts" : "no_counts"}`;

			try {
				// Intentar obtener datos de la cach√© primero si no se fuerza refresh
				if (!forceRefresh) {
					const cachedData = CacheService.getItem(cacheKey);
					if (cachedData && cachedData.data) {
						console.log("üíæ useCategories: Usando categor√≠as en cach√©");
						setCategories(cachedData.data || []);
						setLoading(false);
						return cachedData;
					}
				}

				console.log(
					"üåê useCategories: Obteniendo categor√≠as desde API con withCounts:",
					withCounts
				);

				// Hacer la petici√≥n a la API
				const response = await categoryService.getCategories({
					with_counts: withCounts,
					is_active: true,
					with_children: true, // ‚úÖ AGREGADO: solicitar subcategor√≠as
				});

				console.log(
					"üì• useCategories: Respuesta de categor√≠as desde API:",
					response
				);

				if (response && response.data && Array.isArray(response.data)) {
					// Adaptar datos
					const adaptedCategories = response.data.map(adaptCategory);

					const result = {
						data: adaptedCategories,
						meta: response.meta || {total: adaptedCategories.length},
					};

					// Guardar en cach√©
					CacheService.setItem(
						cacheKey,
						result,
						appConfig.cache.categoryCacheTime
					);

					setCategories(adaptedCategories);
					return result;
				} else {
					console.warn(
						"‚ö†Ô∏è useCategories: Respuesta de categor√≠as no tiene el formato esperado:",
						response
					);
					setCategories([]);
					return {data: [], meta: {total: 0}};
				}
			} catch (err) {
				const errorMessage =
					err instanceof Error ? err.message : "Error al obtener categor√≠as";
				setError(errorMessage);
				console.error("‚ùå useCategories: Error al obtener categor√≠as:", err);
				setCategories([]);
				return {data: [], meta: {total: 0}};
			} finally {
				setLoading(false);
			}
		},
		[adaptCategory]
	);

	/**
	 * Obtener categor√≠as principales
	 */
	const fetchMainCategories = useCallback(
		async (withCounts: boolean = true, forceRefresh: boolean = false) => {
			setLoading(true);
			setError(null);

			const cacheKey = `categories_main_${withCounts ? "with_counts" : "no_counts"}`;

			try {
				// Intentar obtener datos de la cach√© primero
				if (!forceRefresh) {
					const cachedData = CacheService.getItem(cacheKey);
					if (cachedData) {
						console.log(
							"üíæ useCategories: Usando categor√≠as principales en cach√©"
						);
						setMainCategories(cachedData);
						setLoading(false);
						return cachedData;
					}
				}

				console.log(
					"üåê useCategories: Obteniendo categor√≠as principales desde API"
				);

				// Hacer la petici√≥n a la API para categor√≠as principales
				const response = await categoryService.getMainCategories(withCounts);

				console.log(
					"üì• useCategories: Respuesta de categor√≠as principales desde API:",
					response
				);

				// ‚úÖ CORREGIDO: Verificar la estructura correcta {data: [...], meta: {...}}
				if (response && response.data && Array.isArray(response.data)) {
					// Adaptar datos del array dentro de data
					const adaptedCategories = response.data.map(adaptCategory);

					// Guardar en cach√©
					CacheService.setItem(
						cacheKey,
						adaptedCategories,
						appConfig.cache.categoryCacheTime
					);

					setMainCategories(adaptedCategories);
					console.log(
						"‚úÖ useCategories: Categor√≠as principales procesadas correctamente:",
						adaptedCategories.length
					);
					return adaptedCategories;
				} else {
					console.warn(
						"‚ö†Ô∏è useCategories: Respuesta de categor√≠as principales no tiene el formato esperado:",
						response
					);
					setMainCategories([]);
					return [];
				}
			} catch (err) {
				const errorMessage =
					err instanceof Error
						? err.message
						: "Error al obtener categor√≠as principales";
				setError(errorMessage);
				console.error(
					"‚ùå useCategories: Error al obtener categor√≠as principales:",
					err
				);
				setMainCategories([]);
				return [];
			} finally {
				setLoading(false);
			}
		},
		[adaptCategory]
	);

	/**
	 * Obtener categor√≠as destacadas
	 */
	const fetchFeaturedCategories = useCallback(
		async (limit: number = 8, forceRefresh: boolean = false) => {
			setLoading(true);
			setError(null);

			const cacheKey = `categories_featured_${limit}`;

			try {
				// Intentar obtener datos de la cach√© primero
				if (!forceRefresh) {
					const cachedData = CacheService.getItem(cacheKey);
					if (cachedData) {
						console.log(
							"üíæ useCategories: Usando categor√≠as destacadas en cach√©"
						);
						setFeaturedCategories(cachedData);
						setLoading(false);
						return cachedData;
					}
				}

				console.log(
					"üåê useCategories: Obteniendo categor√≠as destacadas desde API"
				);

				// Hacer la petici√≥n a la API
				const response = await categoryService.getFeaturedCategories(limit);

				console.log(
					"üì• useCategories: Respuesta de categor√≠as destacadas desde API:",
					response
				);

				// ‚úÖ CORREGIDO: Verificar si es array directamente O si tiene estructura {data: [...]}
				let categoriesToProcess = [];
				if (Array.isArray(response)) {
					categoriesToProcess = response;
				} else if (response && response.data && Array.isArray(response.data)) {
					categoriesToProcess = response.data;
				}

				if (categoriesToProcess.length > 0) {
					// Adaptar datos
					const adaptedCategories = categoriesToProcess.map(adaptCategory);

					// Guardar en cach√©
					CacheService.setItem(
						cacheKey,
						adaptedCategories,
						appConfig.cache.categoryCacheTime
					);

					setFeaturedCategories(adaptedCategories);
					console.log(
						"‚úÖ useCategories: Categor√≠as destacadas procesadas correctamente:",
						adaptedCategories.length
					);
					return adaptedCategories;
				} else {
					console.warn(
						"‚ö†Ô∏è useCategories: Respuesta de categor√≠as destacadas no tiene el formato esperado:",
						response
					);
					setFeaturedCategories([]);
					return [];
				}
			} catch (err) {
				const errorMessage =
					err instanceof Error
						? err.message
						: "Error al obtener categor√≠as destacadas";
				setError(errorMessage);
				console.error(
					"‚ùå useCategories: Error al obtener categor√≠as destacadas:",
					err
				);
				setFeaturedCategories([]);
				return [];
			} finally {
				setLoading(false);
			}
		},
		[adaptCategory]
	);

	/**
	 * Obtener subcategor√≠as de una categor√≠a
	 */
	const fetchSubcategories = useCallback(
		async (categoryId: number) => {
			setLoading(true);
			setError(null);

			const cacheKey = `categories_subcats_${categoryId}`;

			try {
				// Intentar obtener datos de la cach√© primero
				const cachedData = CacheService.getItem(cacheKey);

				if (cachedData) {
					console.log(
						`üíæ useCategories: Usando subcategor√≠as en cach√© para categor√≠a ${categoryId}`
					);
					setLoading(false);
					return cachedData;
				}

				// Si no hay cach√©, hacer la petici√≥n a la API
				const response = await categoryService.getSubcategories(categoryId);

				console.log(
					`üì• useCategories: Respuesta de subcategor√≠as para categor√≠a ${categoryId}:`,
					response
				);

				// ‚úÖ CORREGIDO: Verificar si es array directamente O si tiene estructura {data: [...]}
				let categoriesToProcess = [];
				if (Array.isArray(response)) {
					categoriesToProcess = response;
				} else if (response && response.data && Array.isArray(response.data)) {
					categoriesToProcess = response.data;
				}

				if (categoriesToProcess.length > 0) {
					// Adaptar datos
					const adaptedCategories = categoriesToProcess.map(adaptCategory);

					// Guardar en cach√©
					CacheService.setItem(
						cacheKey,
						adaptedCategories,
						appConfig.cache.categoryCacheTime
					);

					console.log(
						`‚úÖ useCategories: Subcategor√≠as procesadas correctamente para categor√≠a ${categoryId}:`,
						adaptedCategories.length
					);
					return adaptedCategories;
				}

				return [];
			} catch (err) {
				const errorMessage =
					err instanceof Error ? err.message : "Error al obtener subcategor√≠as";
				setError(errorMessage);
				console.error("‚ùå useCategories: Error al obtener subcategor√≠as:", err);
				return [];
			} finally {
				setLoading(false);
			}
		},
		[adaptCategory]
	);

	/**
	 * Obtener categor√≠a por su slug
	 */
	const fetchCategoryBySlug = useCallback(
		async (slug: string) => {
			setLoading(true);
			setError(null);

			const cacheKey = `category_slug_${slug}`;

			try {
				// Intentar obtener datos de la cach√© primero
				const cachedData = CacheService.getItem(cacheKey);

				if (cachedData) {
					console.log(
						`üíæ useCategories: Usando categor√≠a en cach√© para slug ${slug}`
					);
					setCategoryDetail(cachedData);
					setLoading(false);
					return cachedData;
				}

				// Si no hay cach√©, hacer la petici√≥n a la API
				const response = await categoryService.getCategoryBySlug(slug);

				console.log(
					`üì• useCategories: Respuesta de categor√≠a con slug ${slug}:`,
					response
				);

				if (response) {
					// Adaptar datos
					const adaptedCategory = adaptCategory(response);

					// Guardar en cach√©
					CacheService.setItem(
						cacheKey,
						adaptedCategory,
						appConfig.cache.categoryCacheTime
					);

					setCategoryDetail(adaptedCategory);
					return adaptedCategory;
				}

				setCategoryDetail(null);
				return null;
			} catch (err) {
				const errorMessage =
					err instanceof Error
						? err.message
						: "Error al obtener categor√≠a por slug";
				setError(errorMessage);
				console.error(
					"‚ùå useCategories: Error al obtener categor√≠a por slug:",
					err
				);
				setCategoryDetail(null);
				return null;
			} finally {
				setLoading(false);
			}
		},
		[adaptCategory]
	);

	/**
	 * Limpiar cach√© de categor√≠as
	 */
	const clearCategoryCache = useCallback(() => {
		// Identificar y limpiar todas las claves de cach√© relacionadas con categor√≠as
		const allKeys = Object.keys(localStorage);
		const categoryKeys = allKeys.filter(
			(key) => key.startsWith("category_") || key.startsWith("categories_")
		);

		categoryKeys.forEach((key) => {
			CacheService.removeItem(key);
		});

		console.log(
			`üóëÔ∏è useCategories: ${categoryKeys.length} claves de cach√© de categor√≠as eliminadas`
		);
	}, []);

	return {
		// Estados
		loading,
		error,
		categories,
		mainCategories,
		featuredCategories,
		categoryDetail,
		isInitialized,

		// M√©todos
		fetchCategories,
		fetchMainCategories,
		fetchFeaturedCategories,
		fetchSubcategories,
		fetchCategoryBySlug,
		clearCategoryCache,

		// Utilidades
		setError: (error: string | null) => setError(error),
		setLoading: (loading: boolean) => setLoading(loading),
	};
};

export default useCategories;
